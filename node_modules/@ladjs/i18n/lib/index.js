'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var _require = require('path');

const extname = _require.extname,
      resolve = _require.resolve;

var _require2 = require('qs');

const stringify = _require2.stringify;

const Boom = require('boom');
const s = require('underscore.string');

var _require3 = require('lodash');

const isEmpty = _require3.isEmpty,
      sortBy = _require3.sortBy,
      every = _require3.every,
      isFunction = _require3.isFunction;

var _require4 = require('country-language');

const getLanguage = _require4.getLanguage;

const moment = require('moment');
const i18n = require('i18n');
const locales = require('i18n-locales');
const autoBind = require('auto-bind');
const debug = require('debug')('ladjs:i18n');
const boolean = require('boolean');

// expose global
i18n.api = {};

class I18N {
  constructor(config = {}) {
    this.config = Object.assign({
      phrases: {},
      logger: console,
      directory: resolve('locales'),
      locales: ['en', 'es', 'zh'],
      cookie: 'locale',
      indent: '  ',
      defaultLocale: 'en',
      syncFiles: boolean(process.env.I18N_SYNC_FILES),
      autoReload: boolean(process.env.I18N_AUTO_RELOAD),
      updateFiles: boolean(process.env.I18N_UPDATE_FILES),
      api: {
        __: 't',
        __n: 'tn',
        __l: 'tl',
        __h: 'th',
        __mf: 'tmf'
      },
      register: i18n.api
    }, config);

    const logger = this.config.logger;


    this.config.logDebugFn = logger.debug;
    this.config.logWarnFn = logger.warn;
    this.config.logErrorFn = logger.error;

    // validate locales against available ones
    if (!every(this.config.locales, l => locales.includes(l))) throw new Error(`Invalid locales: ${this.config.locales.filter(str => !locales.includes(str)).join(', ')}`);

    // inherit i18n object
    Object.assign(this, i18n);

    // configure i18n
    this.configure(this.config);

    autoBind(this);
  }

  translate(key, locale) {
    var _config = this.config;
    const logger = _config.logger,
          phrases = _config.phrases;

    let args = Object.keys(arguments).map(key => arguments[key]).slice(2);
    if (typeof args === 'undefined') args = [];
    const phrase = phrases[key];
    if (typeof phrase !== 'string') {
      logger.warn(`translation key missing: ${key}`);
      return;
    }
    args = [{ phrase, locale }, ...args];
    return i18n.api.t(...args);
  }

  middleware(ctx, next) {
    var _config2 = this.config;
    const locales = _config2.locales,
          defaultLocale = _config2.defaultLocale,
          phrases = _config2.phrases,
          cookie = _config2.cookie;

    // expose api methods to `ctx.req` and `ctx.state`

    i18n.init(ctx.req, ctx.state);

    // expose a helper function to `ctx.state.l`
    // which prefixes a link/path with the locale
    ctx.state.l = (path = '') => {
      return `/${ctx.state.locale}${path}`;
    };

    // override the existing locale detection with our own
    // in order of priority:
    //
    // 1. check the URL, if === `/de` or starts with `/de/` then locale is `de`
    // 2. check the cookie
    // 3. check Accept-Language last
    //
    // also we need to expose `ctx.pathWithoutLocale`
    // as the path without locale

    let locale = locales.find(l => {
      return `/${l}` === ctx.path || ctx.path.indexOf(`/${l}/`) === 0;
    });

    ctx.pathWithoutLocale = locale ? ctx.path.substring(`/${locale}`.length) : ctx.path;
    if (ctx.pathWithoutLocale === '') ctx.pathWithoutLocale = '/';

    if (!locale) {
      locale = defaultLocale;
      if (ctx.cookies.get(cookie) && locales.includes(ctx.cookies.get(cookie))) {
        locale = ctx.cookies.get(cookie);
        debug('found locale via cookie using %s', locale);
      } else if (ctx.request.acceptsLanguages(locales)) {
        locale = ctx.request.acceptsLanguages(locales);
        debug('found locale via Accept-Language header using %s', locale);
      }
    }

    // set the locale properly
    i18n.setLocale([ctx.req, ctx.state], locale);
    ctx.locale = ctx.req.locale;

    // if the locale was not available then redirect user
    if (locale !== ctx.state.locale) return ctx.redirect(`/${ctx.state.locale}${ctx.pathWithoutLocale}${isEmpty(ctx.query) ? '' : `?${stringify(ctx.query)}`}`);

    // available languages for a dropdown menu to change language
    ctx.state.availableLanguages = sortBy(locales.map(locale => {
      return {
        locale,
        url: `/${locale}${ctx.pathWithoutLocale}${isEmpty(ctx.query) ? '' : `?${stringify(ctx.query)}`}`,
        name: getLanguage(locale).name[0]
      };
    }), 'name');

    // get the name of the current locale's language in native language
    ctx.state.currentLanguage = s.titleize(getLanguage(ctx.req.locale).nativeName[0]);

    // bind `ctx.translate` as a helper func
    // so you can pass `ctx.translate('SOME_KEY_IN_CONFIG');` and it will lookup
    // `phrases['SOMETHING']` to get a specific and constant message
    // and then it will call `t` to translate it to the user's locale
    ctx.translate = function () {
      if (typeof arguments[0] !== 'string' || typeof phrases[arguments[0]] !== 'string') return ctx.throw(Boom.badRequest('Translation for your locale failed, try again'));
      arguments[0] = phrases[arguments[0]];
      return ctx.req.t(...arguments);
    };

    return next();
  }

  redirect(ctx, next) {
    var _this = this;

    return _asyncToGenerator(function* () {
      debug('attempting to redirect');
      // do not redirect static paths
      if (extname(ctx.path) !== '') return next();

      // inspired by nodejs.org language support
      // <https://github.com/nodejs/nodejs.org/commit/d6cdd942a8fc0fffcf6879eca124295e95991bbc#diff-78c12f5adc1848d13b1c6f07055d996eR59>
      const locale = ctx.url.split('/')[1].split('?')[0];
      const hasLang = _this.config.locales.includes(locale);

      // if the URL did not have a valid language found
      // then redirect the user to their detected locale
      if (!hasLang) {
        ctx.status = 302;
        let redirect = `/${ctx.req.locale}${ctx.url}`;
        if (!isEmpty(ctx.query)) redirect += `?${stringify(ctx.query)}`;
        debug('no valid locale found in URL, redirecting to %s', redirect);
        return ctx.redirect(redirect);
      }

      debug('found valid language "%s"', locale);

      // set the cookie for future requests
      ctx.cookies.set(_this.config.cookie, locale, {
        // Disable signed cookies in NODE_ENV=test
        signed: process.env.NODE_ENV !== 'test',
        expires: moment().add(1, 'year').toDate()
      });
      debug('set cookies for locale "%s"', locale);

      // if the user is logged in and ctx.isAuthenticated() exists,
      // then save it as `last_locale`
      if (isFunction(ctx.isAuthenticated) && ctx.isAuthenticated()) {
        ctx.state.user.last_locale = locale;
        try {
          yield ctx.state.user.save();
        } catch (err) {
          _this.config.logger.error(err);
        }
      }

      return next();
    })();
  }
}

module.exports = I18N;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiZXh0bmFtZSIsInJlc29sdmUiLCJzdHJpbmdpZnkiLCJCb29tIiwicyIsImlzRW1wdHkiLCJzb3J0QnkiLCJldmVyeSIsImlzRnVuY3Rpb24iLCJnZXRMYW5ndWFnZSIsIm1vbWVudCIsImkxOG4iLCJsb2NhbGVzIiwiYXV0b0JpbmQiLCJkZWJ1ZyIsImJvb2xlYW4iLCJhcGkiLCJJMThOIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJPYmplY3QiLCJhc3NpZ24iLCJwaHJhc2VzIiwibG9nZ2VyIiwiY29uc29sZSIsImRpcmVjdG9yeSIsImNvb2tpZSIsImluZGVudCIsImRlZmF1bHRMb2NhbGUiLCJzeW5jRmlsZXMiLCJwcm9jZXNzIiwiZW52IiwiSTE4Tl9TWU5DX0ZJTEVTIiwiYXV0b1JlbG9hZCIsIkkxOE5fQVVUT19SRUxPQUQiLCJ1cGRhdGVGaWxlcyIsIkkxOE5fVVBEQVRFX0ZJTEVTIiwiX18iLCJfX24iLCJfX2wiLCJfX2giLCJfX21mIiwicmVnaXN0ZXIiLCJsb2dEZWJ1Z0ZuIiwibG9nV2FybkZuIiwid2FybiIsImxvZ0Vycm9yRm4iLCJlcnJvciIsImwiLCJpbmNsdWRlcyIsIkVycm9yIiwiZmlsdGVyIiwic3RyIiwiam9pbiIsImNvbmZpZ3VyZSIsInRyYW5zbGF0ZSIsImtleSIsImxvY2FsZSIsImFyZ3MiLCJrZXlzIiwiYXJndW1lbnRzIiwibWFwIiwic2xpY2UiLCJwaHJhc2UiLCJ0IiwibWlkZGxld2FyZSIsImN0eCIsIm5leHQiLCJpbml0IiwicmVxIiwic3RhdGUiLCJwYXRoIiwiZmluZCIsImluZGV4T2YiLCJwYXRoV2l0aG91dExvY2FsZSIsInN1YnN0cmluZyIsImxlbmd0aCIsImNvb2tpZXMiLCJnZXQiLCJyZXF1ZXN0IiwiYWNjZXB0c0xhbmd1YWdlcyIsInNldExvY2FsZSIsInJlZGlyZWN0IiwicXVlcnkiLCJhdmFpbGFibGVMYW5ndWFnZXMiLCJ1cmwiLCJuYW1lIiwiY3VycmVudExhbmd1YWdlIiwidGl0bGVpemUiLCJuYXRpdmVOYW1lIiwidGhyb3ciLCJiYWRSZXF1ZXN0Iiwic3BsaXQiLCJoYXNMYW5nIiwic3RhdHVzIiwic2V0Iiwic2lnbmVkIiwiTk9ERV9FTlYiLCJleHBpcmVzIiwiYWRkIiwidG9EYXRlIiwiaXNBdXRoZW50aWNhdGVkIiwidXNlciIsImxhc3RfbG9jYWxlIiwic2F2ZSIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7ZUFBNkJBLFFBQVEsTUFBUixDOztNQUFyQkMsTyxZQUFBQSxPO01BQVNDLE8sWUFBQUEsTzs7Z0JBQ0tGLFFBQVEsSUFBUixDOztNQUFkRyxTLGFBQUFBLFM7O0FBQ1IsTUFBTUMsT0FBT0osUUFBUSxNQUFSLENBQWI7QUFDQSxNQUFNSyxJQUFJTCxRQUFRLG1CQUFSLENBQVY7O2dCQUMrQ0EsUUFBUSxRQUFSLEM7O01BQXZDTSxPLGFBQUFBLE87TUFBU0MsTSxhQUFBQSxNO01BQVFDLEssYUFBQUEsSztNQUFPQyxVLGFBQUFBLFU7O2dCQUNSVCxRQUFRLGtCQUFSLEM7O01BQWhCVSxXLGFBQUFBLFc7O0FBQ1IsTUFBTUMsU0FBU1gsUUFBUSxRQUFSLENBQWY7QUFDQSxNQUFNWSxPQUFPWixRQUFRLE1BQVIsQ0FBYjtBQUNBLE1BQU1hLFVBQVViLFFBQVEsY0FBUixDQUFoQjtBQUNBLE1BQU1jLFdBQVdkLFFBQVEsV0FBUixDQUFqQjtBQUNBLE1BQU1lLFFBQVFmLFFBQVEsT0FBUixFQUFpQixZQUFqQixDQUFkO0FBQ0EsTUFBTWdCLFVBQVVoQixRQUFRLFNBQVIsQ0FBaEI7O0FBRUE7QUFDQVksS0FBS0ssR0FBTCxHQUFXLEVBQVg7O0FBRUEsTUFBTUMsSUFBTixDQUFXO0FBQ1RDLGNBQVlDLFNBQVMsRUFBckIsRUFBeUI7QUFDdkIsU0FBS0EsTUFBTCxHQUFjQyxPQUFPQyxNQUFQLENBQ1o7QUFDRUMsZUFBUyxFQURYO0FBRUVDLGNBQVFDLE9BRlY7QUFHRUMsaUJBQVd4QixR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OztBQUVBO0FBQ0FTLFVBQUlXLE9BQUosQ0FBWWtCLEdBQVosQ0FBZ0IsTUFBSzVFLE1BQUwsQ0FBWU8sTUFBNUIsRUFBb0MrQixNQUFwQyxFQUE0QztBQUMxQztBQUNBdUMsZ0JBQVFsRSxRQUFRQyxHQUFSLENBQVlrRSxRQUFaLEtBQXlCLE1BRlM7QUFHMUNDLGlCQUFTeEYsU0FDTnlGLEdBRE0sQ0FDRixDQURFLEVBQ0MsTUFERCxFQUVOQyxNQUZNO0FBSGlDLE9BQTVDO0FBT0F0RixZQUFNLDZCQUFOLEVBQXFDMkMsTUFBckM7O0FBRUE7QUFDQTtBQUNBLFVBQUlqRCxXQUFXMEQsSUFBSW1DLGVBQWYsS0FBbUNuQyxJQUFJbUMsZUFBSixFQUF2QyxFQUE4RDtBQUM1RG5DLFlBQUlJLEtBQUosQ0FBVWdDLElBQVYsQ0FBZUMsV0FBZixHQUE2QjlDLE1BQTdCO0FBQ0EsWUFBSTtBQUNGLGdCQUFNUyxJQUFJSSxLQUFKLENBQVVnQyxJQUFWLENBQWVFLElBQWYsRUFBTjtBQUNELFNBRkQsQ0FFRSxPQUFPQyxHQUFQLEVBQVk7QUFDWixnQkFBS3RGLE1BQUwsQ0FBWUksTUFBWixDQUFtQndCLEtBQW5CLENBQXlCMEQsR0FBekI7QUFDRDtBQUNGOztBQUVELGFBQU90QyxNQUFQO0FBM0N3QjtBQTRDekI7QUEzTVE7O0FBOE1YdUMsT0FBT0MsT0FBUCxHQUFpQjFGLElBQWpCIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBleHRuYW1lLCByZXNvbHZlIH0gPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgncXMnKTtcbmNvbnN0IEJvb20gPSByZXF1aXJlKCdib29tJyk7XG5jb25zdCBzID0gcmVxdWlyZSgndW5kZXJzY29yZS5zdHJpbmcnKTtcbmNvbnN0IHsgaXNFbXB0eSwgc29ydEJ5LCBldmVyeSwgaXNGdW5jdGlvbiB9ID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB7IGdldExhbmd1YWdlIH0gPSByZXF1aXJlKCdjb3VudHJ5LWxhbmd1YWdlJyk7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbmNvbnN0IGkxOG4gPSByZXF1aXJlKCdpMThuJyk7XG5jb25zdCBsb2NhbGVzID0gcmVxdWlyZSgnaTE4bi1sb2NhbGVzJyk7XG5jb25zdCBhdXRvQmluZCA9IHJlcXVpcmUoJ2F1dG8tYmluZCcpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdsYWRqczppMThuJyk7XG5jb25zdCBib29sZWFuID0gcmVxdWlyZSgnYm9vbGVhbicpO1xuXG4vLyBleHBvc2UgZ2xvYmFsXG5pMThuLmFwaSA9IHt9O1xuXG5jbGFzcyBJMThOIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIHBocmFzZXM6IHt9LFxuICAgICAgICBsb2dnZXI6IGNvbnNvbGUsXG4gICAgICAgIGRpcmVjdG9yeTogcmVzb2x2ZSgnbG9jYWxlcycpLFxuICAgICAgICBsb2NhbGVzOiBbJ2VuJywgJ2VzJywgJ3poJ10sXG4gICAgICAgIGNvb2tpZTogJ2xvY2FsZScsXG4gICAgICAgIGluZGVudDogJyAgJyxcbiAgICAgICAgZGVmYXVsdExvY2FsZTogJ2VuJyxcbiAgICAgICAgc3luY0ZpbGVzOiBib29sZWFuKHByb2Nlc3MuZW52LkkxOE5fU1lOQ19GSUxFUyksXG4gICAgICAgIGF1dG9SZWxvYWQ6IGJvb2xlYW4ocHJvY2Vzcy5lbnYuSTE4Tl9BVVRPX1JFTE9BRCksXG4gICAgICAgIHVwZGF0ZUZpbGVzOiBib29sZWFuKHByb2Nlc3MuZW52LkkxOE5fVVBEQVRFX0ZJTEVTKSxcbiAgICAgICAgYXBpOiB7XG4gICAgICAgICAgX186ICd0JyxcbiAgICAgICAgICBfX246ICd0bicsXG4gICAgICAgICAgX19sOiAndGwnLFxuICAgICAgICAgIF9faDogJ3RoJyxcbiAgICAgICAgICBfX21mOiAndG1mJ1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlcjogaTE4bi5hcGlcbiAgICAgIH0sXG4gICAgICBjb25maWdcbiAgICApO1xuXG4gICAgY29uc3QgeyBsb2dnZXIgfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgdGhpcy5jb25maWcubG9nRGVidWdGbiA9IGxvZ2dlci5kZWJ1ZztcbiAgICB0aGlzLmNvbmZpZy5sb2dXYXJuRm4gPSBsb2dnZXIud2FybjtcbiAgICB0aGlzLmNvbmZpZy5sb2dFcnJvckZuID0gbG9nZ2VyLmVycm9yO1xuXG4gICAgLy8gdmFsaWRhdGUgbG9jYWxlcyBhZ2FpbnN0IGF2YWlsYWJsZSBvbmVzXG4gICAgaWYgKCFldmVyeSh0aGlzLmNvbmZpZy5sb2NhbGVzLCBsID0+IGxvY2FsZXMuaW5jbHVkZXMobCkpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBsb2NhbGVzOiAke3RoaXMuY29uZmlnLmxvY2FsZXNcbiAgICAgICAgICAuZmlsdGVyKHN0ciA9PiAhbG9jYWxlcy5pbmNsdWRlcyhzdHIpKVxuICAgICAgICAgIC5qb2luKCcsICcpfWBcbiAgICAgICk7XG5cbiAgICAvLyBpbmhlcml0IGkxOG4gb2JqZWN0XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpMThuKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBpMThuXG4gICAgdGhpcy5jb25maWd1cmUodGhpcy5jb25maWcpO1xuXG4gICAgYXV0b0JpbmQodGhpcyk7XG4gIH1cblxuICB0cmFuc2xhdGUoa2V5LCBsb2NhbGUpIHtcbiAgICBjb25zdCB7IGxvZ2dlciwgcGhyYXNlcyB9ID0gdGhpcy5jb25maWc7XG4gICAgbGV0IGFyZ3MgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpXG4gICAgICAubWFwKGtleSA9PiBhcmd1bWVudHNba2V5XSlcbiAgICAgIC5zbGljZSgyKTtcbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnKSBhcmdzID0gW107XG4gICAgY29uc3QgcGhyYXNlID0gcGhyYXNlc1trZXldO1xuICAgIGlmICh0eXBlb2YgcGhyYXNlICE9PSAnc3RyaW5nJykge1xuICAgICAgbG9nZ2VyLndhcm4oYHRyYW5zbGF0aW9uIGtleSBtaXNzaW5nOiAke2tleX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXJncyA9IFt7IHBocmFzZSwgbG9jYWxlIH0sIC4uLmFyZ3NdO1xuICAgIHJldHVybiBpMThuLmFwaS50KC4uLmFyZ3MpO1xuICB9XG5cbiAgbWlkZGxld2FyZShjdHgsIG5leHQpIHtcbiAgICBjb25zdCB7IGxvY2FsZXMsIGRlZmF1bHRMb2NhbGUsIHBocmFzZXMsIGNvb2tpZSB9ID0gdGhpcy5jb25maWc7XG5cbiAgICAvLyBleHBvc2UgYXBpIG1ldGhvZHMgdG8gYGN0eC5yZXFgIGFuZCBgY3R4LnN0YXRlYFxuICAgIGkxOG4uaW5pdChjdHgucmVxLCBjdHguc3RhdGUpO1xuXG4gICAgLy8gZXhwb3NlIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGBjdHguc3RhdGUubGBcbiAgICAvLyB3aGljaCBwcmVmaXhlcyBhIGxpbmsvcGF0aCB3aXRoIHRoZSBsb2NhbGVcbiAgICBjdHguc3RhdGUubCA9IChwYXRoID0gJycpID0+IHtcbiAgICAgIHJldHVybiBgLyR7Y3R4LnN0YXRlLmxvY2FsZX0ke3BhdGh9YDtcbiAgICB9O1xuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGV4aXN0aW5nIGxvY2FsZSBkZXRlY3Rpb24gd2l0aCBvdXIgb3duXG4gICAgLy8gaW4gb3JkZXIgb2YgcHJpb3JpdHk6XG4gICAgLy9cbiAgICAvLyAxLiBjaGVjayB0aGUgVVJMLCBpZiA9PT0gYC9kZWAgb3Igc3RhcnRzIHdpdGggYC9kZS9gIHRoZW4gbG9jYWxlIGlzIGBkZWBcbiAgICAvLyAyLiBjaGVjayB0aGUgY29va2llXG4gICAgLy8gMy4gY2hlY2sgQWNjZXB0LUxhbmd1YWdlIGxhc3RcbiAgICAvL1xuICAgIC8vIGFsc28gd2UgbmVlZCB0byBleHBvc2UgYGN0eC5wYXRoV2l0aG91dExvY2FsZWBcbiAgICAvLyBhcyB0aGUgcGF0aCB3aXRob3V0IGxvY2FsZVxuXG4gICAgbGV0IGxvY2FsZSA9IGxvY2FsZXMuZmluZChsID0+IHtcbiAgICAgIHJldHVybiBgLyR7bH1gID09PSBjdHgucGF0aCB8fCBjdHgucGF0aC5pbmRleE9mKGAvJHtsfS9gKSA9PT0gMDtcbiAgICB9KTtcblxuICAgIGN0eC5wYXRoV2l0aG91dExvY2FsZSA9IGxvY2FsZVxuICAgICAgPyBjdHgucGF0aC5zdWJzdHJpbmcoYC8ke2xvY2FsZX1gLmxlbmd0aClcbiAgICAgIDogY3R4LnBhdGg7XG4gICAgaWYgKGN0eC5wYXRoV2l0aG91dExvY2FsZSA9PT0gJycpIGN0eC5wYXRoV2l0aG91dExvY2FsZSA9ICcvJztcblxuICAgIGlmICghbG9jYWxlKSB7XG4gICAgICBsb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgaWYgKFxuICAgICAgICBjdHguY29va2llcy5nZXQoY29va2llKSAmJlxuICAgICAgICBsb2NhbGVzLmluY2x1ZGVzKGN0eC5jb29raWVzLmdldChjb29raWUpKVxuICAgICAgKSB7XG4gICAgICAgIGxvY2FsZSA9IGN0eC5jb29raWVzLmdldChjb29raWUpO1xuICAgICAgICBkZWJ1ZygnZm91bmQgbG9jYWxlIHZpYSBjb29raWUgdXNpbmcgJXMnLCBsb2NhbGUpO1xuICAgICAgfSBlbHNlIGlmIChjdHgucmVxdWVzdC5hY2NlcHRzTGFuZ3VhZ2VzKGxvY2FsZXMpKSB7XG4gICAgICAgIGxvY2FsZSA9IGN0eC5yZXF1ZXN0LmFjY2VwdHNMYW5ndWFnZXMobG9jYWxlcyk7XG4gICAgICAgIGRlYnVnKCdmb3VuZCBsb2NhbGUgdmlhIEFjY2VwdC1MYW5ndWFnZSBoZWFkZXIgdXNpbmcgJXMnLCBsb2NhbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCB0aGUgbG9jYWxlIHByb3Blcmx5XG4gICAgaTE4bi5zZXRMb2NhbGUoW2N0eC5yZXEsIGN0eC5zdGF0ZV0sIGxvY2FsZSk7XG4gICAgY3R4LmxvY2FsZSA9IGN0eC5yZXEubG9jYWxlO1xuXG4gICAgLy8gaWYgdGhlIGxvY2FsZSB3YXMgbm90IGF2YWlsYWJsZSB0aGVuIHJlZGlyZWN0IHVzZXJcbiAgICBpZiAobG9jYWxlICE9PSBjdHguc3RhdGUubG9jYWxlKVxuICAgICAgcmV0dXJuIGN0eC5yZWRpcmVjdChcbiAgICAgICAgYC8ke2N0eC5zdGF0ZS5sb2NhbGV9JHtjdHgucGF0aFdpdGhvdXRMb2NhbGV9JHtpc0VtcHR5KGN0eC5xdWVyeSlcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiBgPyR7c3RyaW5naWZ5KGN0eC5xdWVyeSl9YH1gXG4gICAgICApO1xuXG4gICAgLy8gYXZhaWxhYmxlIGxhbmd1YWdlcyBmb3IgYSBkcm9wZG93biBtZW51IHRvIGNoYW5nZSBsYW5ndWFnZVxuICAgIGN0eC5zdGF0ZS5hdmFpbGFibGVMYW5ndWFnZXMgPSBzb3J0QnkoXG4gICAgICBsb2NhbGVzLm1hcChsb2NhbGUgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICB1cmw6IGAvJHtsb2NhbGV9JHtjdHgucGF0aFdpdGhvdXRMb2NhbGV9JHtpc0VtcHR5KGN0eC5xdWVyeSlcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogYD8ke3N0cmluZ2lmeShjdHgucXVlcnkpfWB9YCxcbiAgICAgICAgICBuYW1lOiBnZXRMYW5ndWFnZShsb2NhbGUpLm5hbWVbMF1cbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgJ25hbWUnXG4gICAgKTtcblxuICAgIC8vIGdldCB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBsb2NhbGUncyBsYW5ndWFnZSBpbiBuYXRpdmUgbGFuZ3VhZ2VcbiAgICBjdHguc3RhdGUuY3VycmVudExhbmd1YWdlID0gcy50aXRsZWl6ZShcbiAgICAgIGdldExhbmd1YWdlKGN0eC5yZXEubG9jYWxlKS5uYXRpdmVOYW1lWzBdXG4gICAgKTtcblxuICAgIC8vIGJpbmQgYGN0eC50cmFuc2xhdGVgIGFzIGEgaGVscGVyIGZ1bmNcbiAgICAvLyBzbyB5b3UgY2FuIHBhc3MgYGN0eC50cmFuc2xhdGUoJ1NPTUVfS0VZX0lOX0NPTkZJRycpO2AgYW5kIGl0IHdpbGwgbG9va3VwXG4gICAgLy8gYHBocmFzZXNbJ1NPTUVUSElORyddYCB0byBnZXQgYSBzcGVjaWZpYyBhbmQgY29uc3RhbnQgbWVzc2FnZVxuICAgIC8vIGFuZCB0aGVuIGl0IHdpbGwgY2FsbCBgdGAgdG8gdHJhbnNsYXRlIGl0IHRvIHRoZSB1c2VyJ3MgbG9jYWxlXG4gICAgY3R4LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgcGhyYXNlc1thcmd1bWVudHNbMF1dICE9PSAnc3RyaW5nJ1xuICAgICAgKVxuICAgICAgICByZXR1cm4gY3R4LnRocm93KFxuICAgICAgICAgIEJvb20uYmFkUmVxdWVzdCgnVHJhbnNsYXRpb24gZm9yIHlvdXIgbG9jYWxlIGZhaWxlZCwgdHJ5IGFnYWluJylcbiAgICAgICAgKTtcbiAgICAgIGFyZ3VtZW50c1swXSA9IHBocmFzZXNbYXJndW1lbnRzWzBdXTtcbiAgICAgIHJldHVybiBjdHgucmVxLnQoLi4uYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuXG4gIGFzeW5jIHJlZGlyZWN0KGN0eCwgbmV4dCkge1xuICAgIGRlYnVnKCdhdHRlbXB0aW5nIHRvIHJlZGlyZWN0Jyk7XG4gICAgLy8gZG8gbm90IHJlZGlyZWN0IHN0YXRpYyBwYXRoc1xuICAgIGlmIChleHRuYW1lKGN0eC5wYXRoKSAhPT0gJycpIHJldHVybiBuZXh0KCk7XG5cbiAgICAvLyBpbnNwaXJlZCBieSBub2RlanMub3JnIGxhbmd1YWdlIHN1cHBvcnRcbiAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlanMub3JnL2NvbW1pdC9kNmNkZDk0MmE4ZmMwZmZmY2Y2ODc5ZWNhMTI0Mjk1ZTk1OTkxYmJjI2RpZmYtNzhjMTJmNWFkYzE4NDhkMTNiMWM2ZjA3MDU1ZDk5NmVSNTk+XG4gICAgY29uc3QgbG9jYWxlID0gY3R4LnVybC5zcGxpdCgnLycpWzFdLnNwbGl0KCc/JylbMF07XG4gICAgY29uc3QgaGFzTGFuZyA9IHRoaXMuY29uZmlnLmxvY2FsZXMuaW5jbHVkZXMobG9jYWxlKTtcblxuICAgIC8vIGlmIHRoZSBVUkwgZGlkIG5vdCBoYXZlIGEgdmFsaWQgbGFuZ3VhZ2UgZm91bmRcbiAgICAvLyB0aGVuIHJlZGlyZWN0IHRoZSB1c2VyIHRvIHRoZWlyIGRldGVjdGVkIGxvY2FsZVxuICAgIGlmICghaGFzTGFuZykge1xuICAgICAgY3R4LnN0YXR1cyA9IDMwMjtcbiAgICAgIGxldCByZWRpcmVjdCA9IGAvJHtjdHgucmVxLmxvY2FsZX0ke2N0eC51cmx9YDtcbiAgICAgIGlmICghaXNFbXB0eShjdHgucXVlcnkpKSByZWRpcmVjdCArPSBgPyR7c3RyaW5naWZ5KGN0eC5xdWVyeSl9YDtcbiAgICAgIGRlYnVnKCdubyB2YWxpZCBsb2NhbGUgZm91bmQgaW4gVVJMLCByZWRpcmVjdGluZyB0byAlcycsIHJlZGlyZWN0KTtcbiAgICAgIHJldHVybiBjdHgucmVkaXJlY3QocmVkaXJlY3QpO1xuICAgIH1cblxuICAgIGRlYnVnKCdmb3VuZCB2YWxpZCBsYW5ndWFnZSBcIiVzXCInLCBsb2NhbGUpO1xuXG4gICAgLy8gc2V0IHRoZSBjb29raWUgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgIGN0eC5jb29raWVzLnNldCh0aGlzLmNvbmZpZy5jb29raWUsIGxvY2FsZSwge1xuICAgICAgLy8gRGlzYWJsZSBzaWduZWQgY29va2llcyBpbiBOT0RFX0VOVj10ZXN0XG4gICAgICBzaWduZWQ6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcsXG4gICAgICBleHBpcmVzOiBtb21lbnQoKVxuICAgICAgICAuYWRkKDEsICd5ZWFyJylcbiAgICAgICAgLnRvRGF0ZSgpXG4gICAgfSk7XG4gICAgZGVidWcoJ3NldCBjb29raWVzIGZvciBsb2NhbGUgXCIlc1wiJywgbG9jYWxlKTtcblxuICAgIC8vIGlmIHRoZSB1c2VyIGlzIGxvZ2dlZCBpbiBhbmQgY3R4LmlzQXV0aGVudGljYXRlZCgpIGV4aXN0cyxcbiAgICAvLyB0aGVuIHNhdmUgaXQgYXMgYGxhc3RfbG9jYWxlYFxuICAgIGlmIChpc0Z1bmN0aW9uKGN0eC5pc0F1dGhlbnRpY2F0ZWQpICYmIGN0eC5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgY3R4LnN0YXRlLnVzZXIubGFzdF9sb2NhbGUgPSBsb2NhbGU7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjdHguc3RhdGUudXNlci5zYXZlKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb25maWcubG9nZ2VyLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEkxOE47XG4iXX0=